name: Deploy Chess Glicko Pipeline

on:
  push:
    branches: [ main, master ]
    paths:
      - 'src/**'
      - 'terraform/**'
      - 'Dockerfile'
      - 'requirements.txt'
      - 'entrypoint.sh'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: 'false'

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  PROJECT_NAME: chess-glicko

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      ecr_repository_url: ${{ steps.terraform-outputs.outputs.ecr_repository_url }}
      ecs_cluster_name: ${{ steps.terraform-outputs.outputs.ecs_cluster_name }}
      task_definition_arn: ${{ steps.terraform-outputs.outputs.task_definition_arn }}
      s3_bucket_name: ${{ steps.terraform-outputs.outputs.s3_bucket_name }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: Import Existing Resources
      working-directory: ./terraform
      run: |
        echo "Checking for existing resources to import..."
        
        # Import ECR repository if it exists
        if aws ecr describe-repositories --repository-names chess-glicko-pipeline --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "ECR repository exists, importing..."
          terraform import aws_ecr_repository.chess_pipeline chess-glicko-pipeline || true
        fi
        
        # Import CloudWatch log group if it exists
        if aws logs describe-log-groups --log-group-name-prefix /ecs/chess-glicko --region ${{ env.AWS_REGION }} --query 'logGroups[0]' --output text 2>/dev/null | grep -q "/ecs/chess-glicko"; then
          echo "CloudWatch log group exists, importing..."
          terraform import aws_cloudwatch_log_group.chess_pipeline /ecs/chess-glicko || true
        fi
        
        # Import IAM roles if they exist
        if aws iam get-role --role-name chess-glicko-ecs-execution-role 2>/dev/null; then
          echo "ECS execution role exists, importing..."
          terraform import aws_iam_role.ecs_execution_role chess-glicko-ecs-execution-role || true
        fi
        
        if aws iam get-role --role-name chess-glicko-ecs-task-role 2>/dev/null; then
          echo "ECS task role exists, importing..."
          terraform import aws_iam_role.ecs_task_role chess-glicko-ecs-task-role || true
        fi
        
        if aws iam get-role --role-name chess-glicko-eventbridge-role 2>/dev/null; then
          echo "EventBridge role exists, importing..."
          terraform import aws_iam_role.eventbridge_role chess-glicko-eventbridge-role || true
        fi
        
        # Import security group if it exists
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=chess-glicko-ecs-tasks" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null)
        if [ "$SG_ID" != "None" ] && [ -n "$SG_ID" ]; then
          echo "Security group exists, importing..."
          terraform import aws_security_group.ecs_tasks $SG_ID || true
        fi

    - name: Create Terraform Variables
      working-directory: ./terraform
      run: |
        cat > terraform.tfvars <<EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "${{ env.PROJECT_NAME }}"
        notification_email = "${{ secrets.NOTIFICATION_EMAIL }}"
        EOF

    - name: Terraform Plan
      working-directory: ./terraform
      run: terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: ./terraform
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform Outputs
      id: terraform-outputs
      working-directory: ./terraform
      run: |
        echo "=== Debugging Terraform Outputs ==="
        terraform output
        echo "=== Setting GitHub Outputs ==="
        
        # Get outputs and verify they exist
        ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
        CLUSTER_NAME=$(terraform output -raw ecs_cluster_name 2>/dev/null || echo "")
        TASK_ARN=$(terraform output -raw task_definition_arn 2>/dev/null || echo "")
        S3_BUCKET=$(terraform output -raw s3_bucket_name 2>/dev/null || echo "")
        
        # Debug the values
        echo "ECR_URL: '$ECR_URL'"
        echo "CLUSTER_NAME: '$CLUSTER_NAME'"
        echo "TASK_ARN: '$TASK_ARN'"
        echo "S3_BUCKET: '$S3_BUCKET'"
        
        # Set outputs (with error checking)
        if [ -n "$ECR_URL" ]; then
          echo "ecr_repository_url=$ECR_URL" >> $GITHUB_OUTPUT
          echo "✅ Set ecr_repository_url output"
        else
          echo "ERROR: ecr_repository_url is empty"
          exit 1
        fi
        
        if [ -n "$CLUSTER_NAME" ]; then
          echo "ecs_cluster_name=$CLUSTER_NAME" >> $GITHUB_OUTPUT
          echo "✅ Set ecs_cluster_name output"
        else
          echo "ERROR: ecs_cluster_name is empty"
          exit 1
        fi
        
        if [ -n "$TASK_ARN" ]; then
          echo "task_definition_arn=$TASK_ARN" >> $GITHUB_OUTPUT
          echo "✅ Set task_definition_arn output"
        else
          echo "ERROR: task_definition_arn is empty"
          exit 1
        fi
        
        if [ -n "$S3_BUCKET" ]; then
          echo "s3_bucket_name=$S3_BUCKET" >> $GITHUB_OUTPUT
          echo "✅ Set s3_bucket_name output"
        else
          echo "ERROR: s3_bucket_name is empty"
          exit 1
        fi
        
        # Final verification - show what was written to GITHUB_OUTPUT
        echo "=== Final GITHUB_OUTPUT verification ==="
        echo "GITHUB_OUTPUT file contents:"
        cat $GITHUB_OUTPUT || echo "Could not read GITHUB_OUTPUT file"

  build-and-deploy:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Debug Job Dependencies
      run: |
        echo "=== Debugging Job Dependencies ==="
        echo "ECR Repository URL: '${{ needs.deploy-infrastructure.outputs.ecr_repository_url }}'"
        echo "ECS Cluster Name: '${{ needs.deploy-infrastructure.outputs.ecs_cluster_name }}'"
        echo "Task Definition ARN: '${{ needs.deploy-infrastructure.outputs.task_definition_arn }}'"
        echo "S3 Bucket Name: '${{ needs.deploy-infrastructure.outputs.s3_bucket_name }}'"
        
        # Check if any outputs are empty
        if [ -z "${{ needs.deploy-infrastructure.outputs.ecr_repository_url }}" ]; then
          echo "❌ ERROR: ecr_repository_url is empty from previous job"
          echo "This indicates a problem with job output passing"
          exit 1
        else
          echo "✅ ecr_repository_url received successfully"
        fi
        
        if [ -z "${{ needs.deploy-infrastructure.outputs.ecs_cluster_name }}" ]; then
          echo "❌ ERROR: ecs_cluster_name is empty from previous job"
          exit 1
        else
          echo "✅ ecs_cluster_name received successfully"
        fi

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY_URL: ${{ needs.deploy-infrastructure.outputs.ecr_repository_url }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "=== Debug ECR Variables ==="
        echo "ECR_REGISTRY: '$ECR_REGISTRY'"
        echo "ECR_REPOSITORY_URL: '$ECR_REPOSITORY_URL'"
        echo "IMAGE_TAG: '$IMAGE_TAG'"
        
        # If ECR_REPOSITORY_URL is empty, try to get it from AWS directly as fallback
        if [ -z "$ECR_REPOSITORY_URL" ]; then
          echo "⚠️  ECR_REPOSITORY_URL is empty, trying to get it from AWS directly..."
          ECR_REPOSITORY_URL=$(aws ecr describe-repositories \
            --repository-names chess-glicko-pipeline \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$ECR_REPOSITORY_URL" ]; then
            echo "✅ Found ECR repository URL from AWS: '$ECR_REPOSITORY_URL'"
          else
            echo "❌ ERROR: Could not get ECR repository URL from job outputs or AWS directly"
            echo "Check that the ECR repository exists and Terraform outputs are working"
            exit 1
          fi
        fi
        
        # Extract repository name from full URL
        # Expected format: 961341531973.dkr.ecr.region.amazonaws.com/chess-glicko-pipeline
        REPO_NAME=$(echo "$ECR_REPOSITORY_URL" | cut -d'/' -f2)
        echo "REPO_NAME: '$REPO_NAME'"
        
        # Check if REPO_NAME extraction worked
        if [ -z "$REPO_NAME" ]; then
          echo "ERROR: Could not extract repository name from: '$ECR_REPOSITORY_URL'"
          echo "Expected format: account.dkr.ecr.region.amazonaws.com/repository-name"
          exit 1
        fi
        
        echo "=== Building Docker Images ==="
        # Build and tag
        docker build -t $ECR_REGISTRY/$REPO_NAME:latest .
        docker build -t $ECR_REGISTRY/$REPO_NAME:$IMAGE_TAG .
        
        echo "=== Pushing to ECR ==="
        # Push
        docker push $ECR_REGISTRY/$REPO_NAME:latest
        docker push $ECR_REGISTRY/$REPO_NAME:$IMAGE_TAG
        
        echo "=== Successfully pushed images ==="
        echo "  Latest: $ECR_REGISTRY/$REPO_NAME:latest"
        echo "  Tagged: $ECR_REGISTRY/$REPO_NAME:$IMAGE_TAG"

    - name: Update ECS Task Definition
      env:
        CLUSTER_NAME: ${{ needs.deploy-infrastructure.outputs.ecs_cluster_name }}
        ECR_REPOSITORY_URL: ${{ needs.deploy-infrastructure.outputs.ecr_repository_url }}
        TASK_DEFINITION_ARN: ${{ needs.deploy-infrastructure.outputs.task_definition_arn }}
      run: |
        echo "=== Debug Task Definition Update Variables ==="
        echo "CLUSTER_NAME: '$CLUSTER_NAME'"
        echo "ECR_REPOSITORY_URL: '$ECR_REPOSITORY_URL'"
        echo "TASK_DEFINITION_ARN: '$TASK_DEFINITION_ARN'"
        
        # Fallback for ECR repository URL if needed
        if [ -z "$ECR_REPOSITORY_URL" ]; then
          echo "⚠️  ECR_REPOSITORY_URL is empty, trying to get it from AWS directly..."
          ECR_REPOSITORY_URL=$(aws ecr describe-repositories \
            --repository-names chess-glicko-pipeline \
            --query 'repositories[0].repositoryUri' \
            --output text 2>/dev/null || echo "")
        fi
        
        # Fallback for task definition ARN if needed
        if [ -z "$TASK_DEFINITION_ARN" ]; then
          echo "⚠️  TASK_DEFINITION_ARN is empty, trying to get it from AWS directly..."
          TASK_DEFINITION_ARN=$(aws ecs describe-task-definition \
            --task-definition chess-glicko-task \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text 2>/dev/null || echo "")
        fi
        
        # Get current task definition family
        TASK_FAMILY=$(echo "$TASK_DEFINITION_ARN" | cut -d'/' -f2 | cut -d':' -f1)
        echo "Task family: $TASK_FAMILY"
        
        # Get the task definition
        aws ecs describe-task-definition \
          --task-definition $TASK_FAMILY \
          --query taskDefinition > task-def.json
        
        # Update the image
        REPO_NAME=$(echo "$ECR_REPOSITORY_URL" | cut -d'/' -f2)
        NEW_IMAGE="${{ steps.login-ecr.outputs.registry }}/$REPO_NAME:latest"
        echo "New image: $NEW_IMAGE"
        
        # Create new task definition
        jq --arg IMAGE "$NEW_IMAGE" \
          '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' \
          task-def.json > new-task-def.json
        
        # Register new task definition
        NEW_TASK_DEF=$(aws ecs register-task-definition \
          --cli-input-json file://new-task-def.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "✅ Registered new task definition: $NEW_TASK_DEF"

  test-deployment:
    needs: [deploy-infrastructure, build-and-deploy]
    runs-on: ubuntu-latest
    if: github.event.inputs.force_deploy == 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Run Test Pipeline
      env:
        CLUSTER_NAME: ${{ needs.deploy-infrastructure.outputs.ecs_cluster_name }}
        TASK_DEFINITION_ARN: ${{ needs.deploy-infrastructure.outputs.task_definition_arn }}
      run: |
        # Get task definition family name
        TASK_FAMILY=$(echo "$TASK_DEFINITION_ARN" | cut -d'/' -f2 | cut -d':' -f1)
        
        # Get default subnet
        SUBNET_ID=$(aws ec2 describe-subnets \
          --filters "Name=default-for-az,Values=true" \
          --query 'Subnets[0].SubnetId' \
          --output text)
        
        # Calculate test month (previous month)
        TEST_MONTH=$(date -d "$(date +'%Y-%m-01') -1 month" +'%Y-%m')
        
        # Run test task
        TASK_ARN=$(aws ecs run-task \
          --cluster $CLUSTER_NAME \
          --task-definition $TASK_FAMILY \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],assignPublicIp=ENABLED}" \
          --overrides "{\"containerOverrides\":[{\"name\":\"chess-glicko\",\"environment\":[{\"name\":\"PROCESS_MONTH\",\"value\":\"$TEST_MONTH\"}]}]}" \
          --query 'tasks[0].taskArn' \
          --output text)
        
        echo "Test task started: $TASK_ARN"
        echo "Monitor with: aws ecs describe-tasks --cluster $CLUSTER_NAME --tasks $TASK_ARN"