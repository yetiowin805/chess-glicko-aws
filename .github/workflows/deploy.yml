name: Deploy Chess Glicko Pipeline

on:
  push:
    branches: [ main, master ]
    paths:
      - 'src/**'
      - 'terraform/**'
      - 'Dockerfile'
      - 'requirements.txt'
      - 'entrypoint.sh'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if no changes'
        required: false
        default: 'false'

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  PROJECT_NAME: chess-glicko

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      ecr_repository: ${{ steps.terraform.outputs.ecr_repository_url }}
      ecs_cluster: ${{ steps.terraform.outputs.ecs_cluster_name }}
      task_definition: ${{ steps.terraform.outputs.task_definition_arn }}
      s3_bucket: ${{ steps.terraform.outputs.s3_bucket_name }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ./terraform
      run: terraform init

    - name: Create Terraform Variables
      working-directory: ./terraform
      run: |
        cat > terraform.tfvars <<EOF
        aws_region = "${{ env.AWS_REGION }}"
        project_name = "${{ env.PROJECT_NAME }}"
        notification_email = "${{ secrets.NOTIFICATION_EMAIL }}"
        EOF

    - name: Terraform Plan
      working-directory: ./terraform
      run: terraform plan -out=tfplan

    - name: Terraform Apply
      working-directory: ./terraform
      run: |
        # Try to import existing resources before applying
        echo "Checking for existing resources to import..."
        
        # Import ECR repository if it exists
        if aws ecr describe-repositories --repository-names chess-glicko-pipeline --region ${{ env.AWS_REGION }} 2>/dev/null; then
          echo "ECR repository exists, importing..."
          terraform import aws_ecr_repository.chess_pipeline chess-glicko-pipeline || true
        fi
        
        # Import CloudWatch log group if it exists
        if aws logs describe-log-groups --log-group-name-prefix /ecs/chess-glicko --region ${{ env.AWS_REGION }} --query 'logGroups[0]' --output text 2>/dev/null | grep -q "/ecs/chess-glicko"; then
          echo "CloudWatch log group exists, importing..."
          terraform import aws_cloudwatch_log_group.chess_pipeline /ecs/chess-glicko || true
        fi
        
        # Import IAM roles if they exist
        if aws iam get-role --role-name chess-glicko-ecs-execution-role 2>/dev/null; then
          echo "ECS execution role exists, importing..."
          terraform import aws_iam_role.ecs_execution_role chess-glicko-ecs-execution-role || true
        fi
        
        if aws iam get-role --role-name chess-glicko-ecs-task-role 2>/dev/null; then
          echo "ECS task role exists, importing..."
          terraform import aws_iam_role.ecs_task_role chess-glicko-ecs-task-role || true
        fi
        
        if aws iam get-role --role-name chess-glicko-eventbridge-role 2>/dev/null; then
          echo "EventBridge role exists, importing..."
          terraform import aws_iam_role.eventbridge_role chess-glicko-eventbridge-role || true
        fi
        
        # Import security group if it exists
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=chess-glicko-ecs-tasks" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null)
        if [ "$SG_ID" != "None" ] && [ -n "$SG_ID" ]; then
          echo "Security group exists, importing..."
          terraform import aws_security_group.ecs_tasks $SG_ID || true
        fi

        echo "Regenerating plan after imports..."
        terraform plan -out=new-tfplan
        
        terraform apply -auto-approve new-tfplan

    - name: Get Terraform Outputs
      id: terraform
      working-directory: ./terraform
      run: |
        echo "=== Debugging Terraform Outputs ==="
        terraform output
        echo "=== Raw ECR Repository URL ==="
        terraform output -raw ecr_repository_url || echo "ERROR: ecr_repository_url output not found"
        echo "=== Setting GitHub Outputs ==="
        echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
        echo "ecs_cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
        echo "task_definition_arn=$(terraform output -raw task_definition_arn)" >> $GITHUB_OUTPUT
        echo "s3_bucket_name=$(terraform output -raw s3_bucket_name)" >> $GITHUB_OUTPUT

  build-and-deploy:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, tag, and push image to Amazon ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ needs.deploy-infrastructure.outputs.ecr_repository }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Extract repository name from full URL
        REPO_NAME=$(echo $ECR_REPOSITORY | cut -d'/' -f2)
        
        # Build and tag
        docker build -t $ECR_REGISTRY/$REPO_NAME:latest .
        docker build -t $ECR_REGISTRY/$REPO_NAME:$IMAGE_TAG .
        
        # Push
        docker push $ECR_REGISTRY/$REPO_NAME:latest
        docker push $ECR_REGISTRY/$REPO_NAME:$IMAGE_TAG

    - name: Update ECS Task Definition
      env:
        CLUSTER_NAME: ${{ needs.deploy-infrastructure.outputs.ecs_cluster }}
        ECR_REPOSITORY: ${{ needs.deploy-infrastructure.outputs.ecr_repository }}
      run: |
        # Get current task definition
        TASK_FAMILY=$(echo ${{ needs.deploy-infrastructure.outputs.task_definition }} | cut -d'/' -f2 | cut -d':' -f1)
        
        # Get the task definition
        aws ecs describe-task-definition \
          --task-definition $TASK_FAMILY \
          --query taskDefinition > task-def.json
        
        # Update the image
        REPO_NAME=$(echo $ECR_REPOSITORY | cut -d'/' -f2)
        NEW_IMAGE="${{ steps.login-ecr.outputs.registry }}/$REPO_NAME:latest"
        
        # Create new task definition
        jq --arg IMAGE "$NEW_IMAGE" \
          '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)' \
          task-def.json > new-task-def.json
        
        # Register new task definition
        aws ecs register-task-definition \
          --cli-input-json file://new-task-def.json

  test-deployment:
    needs: [deploy-infrastructure, build-and-deploy]
    runs-on: ubuntu-latest
    if: github.event.inputs.force_deploy == 'true' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Run Test Pipeline
      env:
        CLUSTER_NAME: ${{ needs.deploy-infrastructure.outputs.ecs_cluster }}
        TASK_DEFINITION: ${{ needs.deploy-infrastructure.outputs.task_definition }}
      run: |
        # Get task definition family name
        TASK_FAMILY=$(echo $TASK_DEFINITION | cut -d'/' -f2 | cut -d':' -f1)
        
        # Get default subnet
        SUBNET_ID=$(aws ec2 describe-subnets \
          --filters "Name=default-for-az,Values=true" \
          --query 'Subnets[0].SubnetId' \
          --output text)
        
        # Calculate test month (previous month)
        TEST_MONTH=$(date -d "$(date +'%Y-%m-01') -1 month" +'%Y-%m')
        
        # Run test task
        TASK_ARN=$(aws ecs run-task \
          --cluster $CLUSTER_NAME \
          --task-definition $TASK_FAMILY \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_ID],assignPublicIp=ENABLED}" \
          --overrides "{\"containerOverrides\":[{\"name\":\"chess-glicko\",\"environment\":[{\"name\":\"PROCESS_MONTH\",\"value\":\"$TEST_MONTH\"}]}]}" \
          --query 'tasks[0].taskArn' \
          --output text)
        
        echo "Test task started: $TASK_ARN"
        echo "Monitor with: aws ecs describe-tasks --cluster $CLUSTER_NAME --tasks $TASK_ARN"